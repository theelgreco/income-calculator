import { ZodError } from 'zod';
import { StandardSchemaV1 } from './standard-schema';
import { StandardSchemaError } from './validation-error';
import { ContractAnyType, ContractAnyTypeLegacy } from './dsl';
/**
 * Type guard to check if the schema is a standard schema.
 *
 * @param schema - unknown
 * @returns boolean
 */
export declare const isStandardSchema: (schema: unknown) => schema is StandardSchemaV1<unknown, unknown>;
/**
 * Takes in an unknown object and returns either a standard schema or null, if it encounters
 * a legacy zod (<3.24.0) schema it'll return a polyfill for it.
 *
 * @param schema - unknown
 * @returns StandardSchemaV1<unknown, unknown> | null
 */
export declare const parseAsStandardSchema: (schema: unknown) => StandardSchemaV1<unknown, unknown> | null;
/**
 * Since 3.53.0 we've moved to headers using an object with schemas inside it, rather than a top level schema.
 *
 * This makes it easier to merge schemas together.
 *
 * @param data - Data to validate e.g. headers
 * @param schemaObject - Schema object to validate against e.g. { 'x-foo': v.string() }
 * @returns
 */
export declare const validateMultiSchemaObject: (data: unknown, schemaObject: Record<string, ContractAnyType> | ContractAnyTypeLegacy | undefined) => {
    value?: unknown;
    error?: StandardSchemaError | ZodError;
    schemasUsed: Array<StandardSchemaV1<unknown, unknown>>;
};
/**
 * Combines two standard schemas into a single standard schema.
 *
 * The combined schema will run the validation of both schemas and return the result of the first schema that
 * succeeds.
 *
 * If either schema fails, the combined schema will return the issues from both schemas.
 *
 * @param a - StandardSchemaV1<unknown, unknown>
 * @param b - StandardSchemaV1<unknown, unknown>
 * @returns StandardSchemaV1<unknown, unknown>
 */
export declare const combineStandardSchemas: (a: StandardSchemaV1<unknown, unknown>, b: StandardSchemaV1<unknown, unknown>) => StandardSchemaV1<unknown, unknown>;
/**
 * Merges two header schemas together, these can either be legacy zod objects or objects containing standard schemas.
 */
export declare const mergeHeaderSchemasForRoute: (baseSchema: unknown, routeSchema: unknown) => unknown;
/**
 * Similar to validateAgainstStandardSchema, but it takes an unknown schema, it will not validate if no schema provided and will check the schema is
 * valid before validating the data.
 *
 * This is super handy for validating request bodies, headers, etc. as it passes through the data if no schema is provided.
 */
export declare const validateIfSchema: (data: unknown, schema: unknown, { passThroughExtraKeys, }?: {
    passThroughExtraKeys?: boolean | undefined;
}) => {
    value?: unknown;
    error?: StandardSchemaError | ZodError;
    schemasUsed: Array<StandardSchemaV1<unknown, unknown>>;
};
export declare const validateAgainstStandardSchema: (data: unknown, schema: StandardSchemaV1<unknown, unknown>, { passThroughExtraKeys, }?: {
    passThroughExtraKeys?: boolean | undefined;
}) => {
    value?: unknown;
    error?: StandardSchemaError | ZodError;
};
/**
 * Use this to decide whether to return the old-style ZodError or the new-style StandardSchemaError
 */
export declare const areAllSchemasLegacyZod: (schemas: (StandardSchemaV1<unknown, unknown> | null | undefined)[]) => boolean;
